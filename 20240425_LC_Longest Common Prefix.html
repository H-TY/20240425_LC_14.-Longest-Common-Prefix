<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

    <script>


        // ● 測資1
        // const strs = ["flower", "flow", "flight"]
        // Output: "fl"

        // ● 測資2
        const strs = ["dog", "racecar", "car"]
        // Output: ""

        // ● 測資3
        // const strs = ["a"]
        // Output: "a"

        // ● 測資4
        // const strs = ["cir", "car"]
        // Output: "c"

        // ● 測資5
        // const strs = ["darg", "big", "dog"]
        // Output: ""

        // ● 測資6
        // const strs = ["abab", "aba", "abc"]
        // Output: "ab"

        // // 自己寫的Code_A
        // // 先重新排序陣列，由文字短至長，避免後續因字元長度過長，而取值取到 undefined 狀況
        // strs.sort(function (a, b) {
        //     return a.length - b.length
        // })
        // console.log(strs)


        // let t = []
        // // 此空陣列作為紀錄共同重複的值

        // for (let i in strs) {
        //     for (let j = 0; j < strs[0].length; j++) {
        //         if (i === "0") {
        //             // 第一個值(索引0)即為用來當判斷的基準值，故直接跳過
        //             strs[0]
        //         } else if (strs[0][j] === strs[i][j]) {
        //             // 依序判斷於相同索引位置是否有相同的字母，當有一樣時，新增至新的陣列(t)
        //             // console.log([i])
        //             // console.log([j])
        //             t.push(strs[0][j])
        //             // console.log(t)
        //         }
        //     }
        // }
        // // console.log(t)
        // // 用 .filter 找出重複的值
        // let k = t.filter((value, index) => {
        //     return t.indexOf(value) !== index
        // })
        // console.log(k)
        // // 去掉陣列的 , 
        // console.log(k.join(""))
        // // return (`"${k.join("")}"`)


        // // 自己寫的Code_B
        // // 先重新排序陣列，由文字短至長，避免後續因字元長度過長，而取值取到 undefined 狀況
        // strs.sort(function (a, b) {
        //     return a.length - b.length
        // })
        // // console.log(strs)


        // let t = ""
        // // 此空陣列作為紀錄共同重複的值

        // for (let i in strs) {
        //     for (let j = 0; j < strs[0].length; j++) {
        //         if (strs[0][j] === strs[i][j]) {
        //             // 依序判斷於相同索引位置是否有相同的字母，當有一樣時，設定要取至第幾索引
        //             // console.log([i])
        //             // console.log([j])
        //             // 用 .substring 取值，因結尾的索引不包含在內，故需 +1
        //             console.log(strs[i].substring(0, j + 1))
        //             t += strs[i].substring(0, j + 1)
        //         }
        //     }
        // }
        // console.log(t)


        // // 自己寫的Code_C
        // // 先重新排序陣列，由文字短至長，避免後續因字元長度過長，而取值取到 undefined 狀況
        // strs.sort(function (a, b) {
        //     return a.length - b.length
        // })
        // console.log(strs)

        // // 共同前餟字母
        // let t = ""

        // // 因陣列依照字元長度排序後，由最短字元長度與最長字元長度做比較即可
        // for (let j = 0; j < strs[0].length; j++) {
        //     if (strs[0][j] === strs[strs.length - 1][j]) {
        //         console.log(strs[strs.length - 1][j])
        //         // 依序判斷於相同索引位置是否有相同的字母，當有一樣時，設定要取至第幾索引
        //         // 用 .substring 取值，因結尾的索引不包含在內，故需 +1
        //         // console.log(strs[0].substring(0, j + 1))
        //         t = strs[0].substring(0, j + 1)
        //     } else {
        //         break
        //     }
        // }
        // console.log(t)
        // // return t



        // 自己寫的Code_D
        // 先重新排序陣列，由文字短至長，避免後續因字元長度過長，而取值取到 undefined 狀況
        strs.sort(function (a, b) {
            return a.length - b.length
        })
        console.log(strs)

        // 共同前餟字母
        let t = ""

        for (let i in strs) {
            for (let j = 0; j < strs[0].length; j++) {
                if (strs[0][j] === strs[i][j] && i !== 0) {
                    // console.log(strs[i][j])
                    // 依序判斷於相同索引位置是否有相同的字母，當有一樣時，設定要取至第幾索引
                    // 用 .substring 取值，因結尾的索引不包含在內，故需 +1
                    // console.log(strs[0].substring(0, j + 1))
                    t = strs[0].substring(0, j + 1)
                } else {
                    // 若不是相同字母，即刪除對照用strs[0]當下的索引位置的字母
                    // 需先將值改成陣列
                    strs[0] = strs[0].split('')
                    console.log(strs[0])

                    // 再刪除當前索引位置的字母
                    strs[0].splice(j, 1)
                    console.log(strs[0])

                    // 最後 賦值 修改原對照用strs[0]的值，用 .join('') 將陣列改回值後賦值
                    strs[0] = strs[0].join('')
                    console.log(strs[0])
                }
            }
        }
        console.log(t)
        // return t




        /**
         * @param {string[]} strs
         * @return {string}
         */
        var longestCommonPrefix = function (strs) {

            strs.sort(function (a, b) {
                return a.length - b.length
            })
            // console.log(strs)

            let t = ""

            for (let j = 0; j < strs[0].length; j++) {
                if (strs[0][j] === strs[strs.length - 1][j]) {
                    // 依序判斷於相同索引位置是否有相同的字母，當有一樣時，設定要取至第幾索引
                    // console.log([i])
                    // console.log([j])
                    // 用 .substring 取值，因結尾的索引不包含在內，故需 +1
                    // console.log(strs[0].substring(0, j + 1))
                    t = strs[0].substring(0, j + 1)
                }
            }
            console.log(t)
            return t



            // // ● ChpGPT 修改後的 code
            // if (strs.length === 0) return ""; // 如果字串陣列為空，則返回空字串

            // let prefix = ""; // 初始化共同前綴為空字串
            // for (let i = 0; i < strs[0].length; i++) { // 從第一個字串的第一個字母開始比較
            //     let char = strs[0][i]; // 取得當前位置的字母
            //     for (let j = 1; j < strs.length; j++) { // 遍歷其他字串
            //         if (i >= strs[j].length || strs[j][i] !== char) {
            //             // 如果已經超出某個字串的長度，或者當前位置的字母和第一個字串中的字母不同
            //             return prefix; // 返回當前的共同前綴
            //         }
            //     }
            //     prefix += char; // 如果當前位置的字母在所有字串中都相同，則將其加入共同前綴中
            // }
            // return prefix; // 返回最終的共同前綴

        };


    </script>


</body>

</html>